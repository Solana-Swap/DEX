import{by as p,bz as o,bA as s,bB as f,bC as m,bD as O,b2 as e,bE as A,bF as c}from"./Bridge.lzhc31h3.js";import"./index.h3lt6w5e.js";import"./vue.ij1rt9yd.js";import"./lodash-es.bp0zmem9.js";import"./axios.i01mok01.js";import"./dayjs.pb8a0t5b.js";import"./swiper.jxnsts7f.js";import"./vuex.i01hmc51.js";import"./vue-router.ii2ni9cp.js";import"./svg-icons.nc57d0by.js";class b extends Error{constructor(r){super(r)}}class E extends b{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}const y=p([o("mintAuthorityOption"),s("mintAuthority"),f("supply"),m("decimals"),O("isInitialized"),o("freezeAuthorityOption"),s("freezeAuthority")]);y.span;async function K(t,r,i=!1,a=A,n=c){if(!i&&!e.isOnCurve(r.toBuffer()))throw new E;const[u]=await e.findProgramAddress([r.toBuffer(),a.toBuffer(),t.toBuffer()],n);return u}export{c as ASSOCIATED_TOKEN_PROGRAM_ID,y as MintLayout,A as TOKEN_PROGRAM_ID,b as TokenError,E as TokenOwnerOffCurveError,K as getAssociatedTokenAddress};
